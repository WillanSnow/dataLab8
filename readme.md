# 选题

## 电子钱包

主要实现功能：
- 客户之间进行交易、查看交易详情、统计查看等等
  - 身份验证、统计交易
- 管理员查看交易记录
- 登录验证。。

客户：提醒、存钱、取钱、交易、查看账户的交易记录

经理：管理客户（开户、查询、提升限额、注销），月流水在主页展示

通用：登录，[手机号验证]。

# 分工

1. 文档+主程序：主程序（gui、调用接口），写文档；
2. 接口部分+ppt：程序访问数据库的函数、展示ppt、部分数据库实现；
3. 数据库部分：部分数据库实现

数据库实现包含：数据库设计；表、用户、权限、触发器，初始化一些数据等等。

分工可以再调整，感觉数据库部分可能会多一点，最后每个人可能都会写一点文档、ppt。

前端：实现展示框架、调用接口(陈瑞祺)
后端：数据库设计、*(实现、接口实现)*
报告：文档、ppt

# 数据库设计

以功能为导向：

**实体集：**

1. **账户**：账号，密码，手机号
2. **客户**：客户ID，姓名，余额，限额
3. **经理**：经理ID，姓名
4. **交易**：交易ID，发起客户，接收客户，交易状态，金额

**关系集：**

- 账户-客户：拥有
- 账户-经理：拥有
- 客户-交易：修改交易状态（发起、接收、拒绝、撤销）、修改时间
- 经理-交易：强制回退交易、修改时间、
- 经理-客户：开户、销户、修改密码、修改限额
- 经理不能修改自己的密码，只能通过后台的数据库管理员。

<font size = 10>需要阅读的部分</font>

## 数据库细节

除账号外，所有主键用`AUTO_INCREMENT`关键字生成。
>您好！如果您希望在表中添加元组时自动生成主键，您可以使用自增长列（auto-increment column）来实现。这样可以确保每个新行都有一个唯一的主键值，而无需用户手动指定。
>
>以下是一些常用数据库的自动生成主键的方法：
>
>- MySQL：使用 `AUTO_INCREMENT` 关键字来创建自增长列。
>- PostgreSQL：使用 `SERIAL` 或 `BIGSERIAL` 数据类型来创建自增长列。
>- Oracle：使用 `SEQUENCE` 对象来创建序列。
>
>例如，如果您使用 MySQL，您可以使用以下语句创建一个带有自增长列的表：
>
>```sql
>CREATE TABLE your_table (
>  id INT NOT NULL AUTO_INCREMENT,
>  col1 VARCHAR(50),
>  col2 VARCHAR(50),
>  PRIMARY KEY (id)
>);
>```
>
>这将创建一个名为 `your_table` 的表，其中包含一个名为 `id` 的自增长列作为主键。
>
>要插入新行，您可以使用以下语句：
>
>```sql
>INSERT INTO your_table (col1, col2) VALUES ('value1', 'value2');
>```

这将插入一行新数据，其中 `id` 列的值将自动设置为下一个可用的唯一值。

- 账户：
  - 账号：标识码，创建账户时，需要随机生成8位数。
  - 密码：10字符以内的字符串
  - 手机号：固定长度为11的一串数字
- 客户：
  - 客户id：5位数字标识码，随机生成或累计的形式。
  - 姓名：客户的名字
  - 余额：账户余额，发起交易时，直接扣除；接收交易时，才增加到目标用户；拒绝交易时，金额回到发起客户余额。
  - 限额：单笔交易的限额。
- 交易：
  - 交易id：15位数字标识码；
  - 金额：交易的额度
  - 状态：整数，0~3，依次表示：待确认、已完成、未成功(接受者取消或发起者撤销)、数据错误(debug或测试用)。
  - cust_a：交易发起客户，存钱时为“system”，取钱时为对应客户；
  - cust_b：交易接收客户，存钱时为对应客户，取钱时为“system”。
- change(客户修改交易状态的记录)：
  - change_id；
  - change_time：修改时间
  - 交易id：被修改的交易
  - cust_id：客户id
  - 修改内容：整数0-4，依次对应：发起交易、接收交易、拒绝交易、撤销交易、数据错误。

# HTML & Python

使用FLask作为前后端交互的方法，falsk库创建一个简单的Web服务器，可以加载多个html页面。当html向服务器发送get请求时，flask可以返回python函数的结果。因此，我们的实现方法为：
- 运行flask创建服务器；
- 服务器运行不同的html页面；
- html页面用于用户操作，当需要访问数据库时，向服务器发送get请求，服务器将结果返回。

## 前端

前端实现效果：

<!-- - 首页：因为我们功能很少，所以直接做一个登录页：
  - 登录：输入账号、密码，点击登录按钮
    - 当用户、密码为空时，点击登录，弹出对应提示。
    - 登录不成功时，根据**登录函数**的返回信息，弹出对应提示：账号不存在；密码错误；
    - 登录成功，跳转经理/客户页面。
  
- 登录后：
  - 客户：查看是否有待完成的交易、发起交易
    - 登录时，显示交易状态改变，从**登录检查函数**获取信息。
    - 用户操作：
      - 存入、取出、交易：分为三个功能，输入金额，‘交易’需要输入交易对象的账号。点击确认后，显示验证界面，需要用户输入预留手机号、验证码，用户输入后，信息后，和登录一样若有信息为空则提示，否则根据**验证函数**的结果展示提示：验证失败、验证成功，交易开始，调用**创建交易函数**。
  - 经理：查看客户信息（不能看密码）、修改客户密码（需要客户预留验证方式的验证，我们不可能真做验证码确认，可以直接改）、查看流水（当日、本月）
    - 查看客户信息：点击/。。之后，展示**客户查询函数**的结果（大概率是表格）
    - 修改密码：输入客户的账号、旧密码、新密码，确认后进入验证环节：输入手机号、验证码，根据**验证函数**的结果，弹出失败信息，或调用**修改密码函数**
    - 查看流水：点击查看流水后，展示**流水查看函数**的结果（表格） -->

## 后端

> 所有的输入都是字符串(大概)
>
> 为了减少sql连接次数，每次登录后，sql连接确定，除登录函数外，其它函数都会有一个登录结构体传入。

登录函数：给定account、password，返回登录结果（-1：登录失败，账号不存在；0：登录失败，密码错误；1：登录成功）

消息提醒函数：给定account，返回等待其确认的交易(即发给他且他未确认的交易)

交易发起函数：给定发起客户、目标客户、金额，若目标客户不存在，金额超过发起客户单笔额度，交易发起失败，返回失败信息；否则发起成功，创建交易(注意创建交易、change元组)。
- **注意**：存、取、交易都是通过这个函数实现的，存由‘系统’账户发起，客户接收；取由客户发起，‘系统’接收。

修改交易：给定客户、交易、操作(接收、撤销、拒绝)，修改数据库对应信息(注意同步余额、trade状态，增加change条目，)

验证函数：给定手机号、验证码，返回验证码是否正确；（由于不可能真正发送短信，所以使用手机号前4位作为验证码。）

客户交易查询函数：给定客户账号，返回有关客户的所有交易（所有状态）。

流水查询函数：返回当日、本月的流水。（有时间可以做最近三天/指定日期的流水）

开户函数：给定姓名、手机号、密码，创建一个客户（创建账户，余额为0，默认限额10000s）

## 数据库登录逻辑

在首页，即登录页面上，数据库没有用户登录。

登录成功后，如果是经理，数据库用以下信息登录：
```python
host = 'localhost'
user = 'managers'
passwd = '12345678'
database = 'lab8'
```
如果是客户，用以下信息登录：
```python
host = 'localhost'
user = 'customers'
passwd = '87654321'
database = 'lab8'
```
登录要返回：Manage_id/Cust_id，flag（true=经理，false=客户），**数据库连接**。
- 连接结构体在进入经理、客户页面后固定，之后的函数都使用这个连接访问数据库。

## 连接权限

主函数使用`root`用户连接，有所有权限。

用户`cust`可以查看所有表，并对`changes, cutomer, trade`表有修改权限。

用户`manager`可以查看所有表，并对`account, customer`表有修改权。

# 项目结构

更新文件夹`Ewallet_Realse`，安装Flask、pysql后，可以运行本网页应用。

如何运行？
- 在Ewallet_Realse目录下，运行`Ewallet.py`；
- 打开浏览器，进入`127.0.0.1:5000`，就能来到应用主页。

## 文件结构

- `Ewallet.py`：服务器主要用于处理Web请求，由我完成
- `templates`：存放各个页面的html，由瑞祺完成；
- `static`：存放静态资源，图片、css、js等等；
- ` src`：存放python代码，主要是数据库访问函数的实现。